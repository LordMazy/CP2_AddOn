-- -*- mode: lua; encoding: windows-1251 -*-
-- solid_list основан на Linspiro Addon v1.1


local rare_list = {

 novice_section = {
 "wpn_toz34",
 "wpn_ak74",
 "wpn_mp5_m1",
 "wpn_colt_m1",
 "wpn_mp5_m2",
 "wpn_walther_m1",
 "wpn_fort_m1",
 "scientific_outfit",
 "stalker_outfit_v3",
 "specops_outfit",
 "dolg_gaz_outfit_m1",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "mutant_flesh_eye",		
 "mutant_boar_leg",		
 "mutant_dog_tail",		  			
 "mutant_zombie_hand",		
 "mutant_face_tushkano",		
 "mutant_tail_cat",				   
 "mutant_spleen_rat",
 "mutant_plague_hand",
 "af_medusa",
 "af_vyvert",
 "af_blood",
 "af_electra_sparkler",
 "af_rusty_thorn",
 "af_ameba_slime",
 "af_drops",      	
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_electra_moonlight",
 "af_gravi",
 "af_cristall_flower",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 "medkit",
 "outfit_soldier_m1",
 "neytral_novice_outfit_m1",
 "neytral_novice_outfit_new",
 "neytral_novice_outfit_cam_1",
 "neytral_novice_outfit_cam_2",
 "neytral_novice_outfit_cam_3",
 "bandit_outfit",
 "bandit_outfit_blue",
 "bandit_outfit_red",
 "mushroom",
 "fake_wpn_knife",
 "sigaret",
 "ammo_9x19_pbp",
 "ammo_11.43x23_hydro",
 "ammo_zhekan_izomorf",
 "mutant_tushkano_cocoon",
 "mutant_dog_cocoon",
 "mutant_psevdodog_cocoon",
 "mutant_flesh_cocoon",
 "mutant_cat_cocoon",
 "mutant_boar_cocoon",
  },

 experienced_section = {
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "ammo_og-7b",
 "ammo_5.45x39_izomorf",
 "ammo_7.62x39_ap",
 "ammo_7.62x51box",
 "mutant_zombie_hand",
 "mutant_snork_leg",				
 "mutant_poltergeist_glas",				
 "mutant_fracture_hand", 
 "mutant_boar_leg",
 "mutant_carlic_hand",
 "part_tarakan_strong",
 "mutant_vypolzen_hrebet",
 "wpn_m16a2_sk1",
 "wpn_sg552_sk1",
 "wpn_wincheaster1300",
 "wpn_m4",
 "wpn_ppsh41_sk2",
 "wpn_abakan_m1",
 "wpn_fort_m1",
 "wpn_winchester_m1",
 "wpn_l85_m1",
 "wpn_l85_m2",
 "wpn_beretta_m1",
 "military_outfit",
 "svoboda_heavy_outfit",
 "dolg_scientific_outfit",
 "freedom_scientific_outfit",
 "merc_scientific_outfit",
 "monolit_scientific_outfit",
 "nebo_scientific_outfit",
 "outfit_dolg_m1",
 "outfit_killer_m1",
 "af_fuzz_kolobok",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_babka_1",
 "af_spirit_1",
 "medkit_army",
 "mutant_zombie_cocoon",
 "mutant_snork_cocoon",
 "mutant_poltergeist_cocoon",
 "amk_kanistra",
 },

 veteran_section = {
 "af_dummy_dummy",
 "af_fuzz_kolobok",
 "af_spirit_1",        
 "af_spirit_2",       
 "af_cry_1",
 "af_babka_1",
 "af_pudd_1",
 "af_pudd_2",
 "af_dik_1",
 "af_kol_1",
 "af_armor_1",
 "af_armor_2",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_eye_voron",
 "ammo_og-7b",
 "grenade_flash",
 "ammo_vog-25p",	
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "ammo_9x39_izomorf",
 "ammo_minigun",
 "ammo_5.56x45_ap",
 "ammo_20x85",
 "ammo_7.62x51_ap",
 "ammo_gauss",
 "nebo_exo_outfit",
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",
 "mutant_zombie_hand",	
 "mutant_hand_kontroler",			
 "mutant_psevdogigant_hand",			
 "mutant_chimera_kogot",
 "mutant_spider_gland",
 "mutant_rotan_heart",
 "mutant_zanoza_leg",
 "wpn_spas12",
 "wpn_m1891_30_scope",
 "wpn_groza",
 "medkit_scientic",
 "mutant_krovosos_cocoon",
 "mutant_burer_cocoon",
 "mutant_chimera_cocoon",
 "amk_ballon",
 },

master_section = {
 "wpn_spas12",
 "wpn_groza",
 "wpn_val_m1",
 "wpn_protecta",	
 "wpn_mp5k_pdw57",
 "wpn_mp5k_pdw_tt",
 "wpn_g3_otdaca_ves",
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",		
 "mutant_hand_kontroler",				
 "mutant_psevdogigant_hand",					
 "mutant_chimera_kogot",
 "mutant_deathclaw_antler",
 "mutant_raptor_kogot",
 "mutant_plague_hand",
 "mozg",
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_og-7b",
 "grenade_rgd5",
 "ammo_7.62x54_izomorf",
 "ammo_7.62x39_k",
 "ammo_7.62x54r",
 "ammo_357_ap_mag",
 "ammo_12.7x108r",
 "ammo_balon",
 "ammo_12.7x108",
 "ammo_super_gauss",
 "svoboda_exoskeleton",
 "nebo_exo_outfit",
 "exo_bandit_outfit",
 "voen_exo_outfit",
 "exo_scientist_outfit",
 "exo_outfit",
 "dolg_black_exoskeleton",
 "killer_green_exoskeleton",
 "seva_scient_outfit",
 "af_simbion",        
 "af_spirit_2",         
 "af_cry_2",
 "af_babka_2",
 "af_pudd_2",
 "af_babka_3",
 "af_dik_2",
 "af_kol_2",
 "af_kol_3",
 "af_armor_2", 
 "af_armor_3",
 "suvorotka",
 "medkit_scientic",
 "mutant_gigant_cocoon",
 "mutant_controller_cocoon",
 }
}

local solid_list = {
 novice_section = {
 --Артефакты--
 "af_drops",
 "af_ameba_slime",
 "af_rusty_thorn",
 "af_electra_sparkler",
 "af_blood",
 "af_vyvert",
 "af_medusa",
 --Аммуниция--
 "grenade_rgd5",
 "ammo_12x70_buck",     
 "ammo_9x19_fmj",
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_9x18_fmj",
 --Оружие--
 "wpn_addon_silencer",
 "wpn_mp5",
 "wpn_bm16",
 "wpn_fort",
 "wpn_pb",
 "wpn_pm",
 --Прочее--
 "bread",
 "bandage",
 "kolbasa",
 "medkit",
 "vodka",
 "sigaret",
 "conserva"
 },

experienced_section = {
--Артефакты--
 "af_cristall_flower",
 "af_gravi",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 --Аммуниция--
 "grenade_rgd5",
 "grenade_gd-05",
 "grenade_flash",
 "grenade_f1",     
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_5.45x39_fmj",
 "ammo_11.43x23_fmj",
 "ammo_5.56x45_ss190",
 --Пушки--
 "wpn_addon_scope",
 "wpn_mp5",
 "wpn_ak74u",
 "wpn_ak74u_m1",
 "wpn_walther",
 --Прочее--
 "mutant_dog_tail",
 "mutant_boar_leg",
 "kolbasa",
 "medkit",
 "antirad",
 "energy_drink",
 "conserva"
 },

 veteran_section = {
 --Артефакты--
 "af_night_star",
 "af_gold_fish",
 "af_soul",
 "af_electra_moonlight",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_cristall",
 --Аммуниция--
 "grenade_f1",
 "ammo_vog-25",     
 "ammo_m209",
 "ammo_5.45x39_ap",
 "ammo_11.43x23_hydro",
 "ammo_9x39_pab9",
 "ammo_5.56x45_ss190",
 "ammo_12x76_zhekan",
 --Пушки--
 "wpn_addon_scope_susat",
 "wpn_addon_grenade_launcher",
 "wpn_beretta",
 "wpn_sig550",
 "wpn_toz34",
 "wpn_abakan_m2",
 "wpn_desert_eagle",
 --Прочее--
 "mutant_psevdodog_tail",
 "mutant_snork_leg",
 "medkit_army",
 "antirad"
 },

 master_section = {
 --Артефакты--
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_fuzz_kolobok",
 --Аммуниция--
 "ammo_m209",
 "ammo_vog-25p",     
 "ammo_9x39_ap",
 "ammo_12x76_dart",
 "ammo_7.62x54_7h14",
 "ammo_9x39_sp5",
 "ammo_5.56x45_ap",
 "ammo_7.62x54_7h1",
 --Пушки--
 "wpn_addon_grenade_launcher_m203",
 "wpn_colt1911",
 "wpn_spas12",
 "wpn_l85",
 "wpn_lr300",
 "wpn_groza",
 "wpn_groza_m1",
 --Прочее--
 "mutant_krovosos_jaw",
 "mutant_burer_hand",
 "medkit_army",
 "medkit_scientic"
 }
}

local treasure_manager = nil
local n_rank 

function parse_items(t)
	if t == nil then
		return {}
	end

	local n = table.getn(t)
		
	local ret_table = {}
	local k = 1

	while k <= n do
		local spawn = {}
		spawn.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		table.insert(ret_table, spawn)
	end
	return ret_table
end


class "CTreasure"
function CTreasure:__init()
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	self.ini = ini_file("misc\\treasure_manager.ltx")

	--' Итерируемся по всем настройкам фраз
	if not self.ini:section_exist("list") then
		abort("There is no section [list] in treasure_manager.ltx")
	end
	
	local n = self.ini:line_count("list")
	local result, id, value = 0,"",""

	--' начальная установка
	self.treasure_info = {}

	for i=0,n-1 do
		result, id, value	= self.ini:r_line("list",i,"","")
		
		self.treasure_info[id] = {}

		self.treasure_info[id].target		= self.ini:r_u32(id, "target")
		self.treasure_info[id].named		= self.ini:r_bool_ex(id, "named", false)
		self.treasure_info[id].name			= self.ini:r_string(id, "name")
		
		--' Отметим тайник как новый
		self.treasure_info[id].active = false
		self.treasure_info[id].done = false

		--print_table(self.treasure_info)
	end

	--' Вспомогательные таблицы для облегчения поиска
	self.treasure_by_target = {}
	for k,v in pairs(self.treasure_info) do
		self.treasure_by_target[v.target] = k	
	end
end
--' Юзание инициатора (возможность выдать тайник)
function CTreasure:use(npc)
--	printf("TREASURE USE")
	
	local se_obj = alife():object(npc:id())
	if se_obj==nil or se_obj.treasure_processed == true then return end
	se_obj.treasure_processed = true
	
	--lootmoney start
	lootmoney.lootmoney(npc)
	--lootmoney end
	
	local rarets 
	
	if npc ~= nil then
	  n_rank = npc:character_rank()
	 else 
      n_rank = 0
	end
	
	-- если выбран редкий тип тайников, то снизим вероятность его выпадения
	if game_options.AmkTrs == 2 then 
	  rarets = 99
	else 
      rarets = 97
  end
--  if amk.is_debug then
 --   rarets=0
--  end
	
	if math.random(100) < rarets then 
	  return
	end
	
	--' Нужно рандомно выбрать один из тайников.
	local avail = {}
	local tr_sum = 0
	local treasure_prob

	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false then
			--local treasure_prob = xr_logic.pick_section_from_condlist(db.actor, npc, v.condlist)
			treasure_prob = xr_logic.pick_section_from_condlist(db.actor, npc,
				xr_logic.parse_condlist(db.actor, "treasure_manager", "condlist", self.ini:r_string_ex(k, "condlist", ""))
			)

			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end

			if tonumber(treasure_prob) >= 0 and v.active == false then
				if tonumber(treasure_prob) == 100 then
					self:give_treasure(k)
				else
					table.insert(avail, {k = k, prob = treasure_prob})
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end

	if tr_sum == 0
		or math.random(100) < 50
	then
		return
	end

	local tr_w = math.random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			--' Выдать тайник
			self:give_treasure(v.k)
			break
		end
	end
end
--' Сохранение
function CTreasure:check()
	--' Проверка тайников
	for k,v in pairs(self.treasure_info) do
		--' Выдать тайник
		self:give_treasure(k)
	end
end
--' Напоминания об активных тайниках на текущей территории
function CTreasure:remind()
	local obj
	local sim = alife()
	local gg = game_graph()
	local have = false
	local sms = "%c[255,255,120,160]Тайники:\\n%c[190,200,200,200]"
	
	for k,v in pairs(self.treasure_info) do
		if v.active then
			obj = sim:story_object(v.target)
			if obj and gg:vertex(obj.m_game_vertex_id):level_id() == sim:level_id() then
				sms = sms..game.translate_string(v.name).."\\n"
				have = true
			end
		end
	end
	
	if have then
		reminder.send_info(sms)
	end
end
--' Выдача тайника
function CTreasure:give_treasure(k)
	local v = self.treasure_info[k]
	local obj = alife():story_object(v.target)
	if obj ~= nil then
		if obj:clsid() ~= clsid.inventory_box then
			abort("Story object [%s] is not an inventory box", v.target)
		end
		
		local lname = alife():level_name(game_graph():vertex(obj.m_game_vertex_id):level_id())
		news_manager.send_treasure(v.name, lname)

		--' Пометить на карте		
		local text = "%c[255,238,155,23]"..game.translate_string(v.name).."\\n"..
			"%c[default]"..game.translate_string(self.ini:r_string(k, "description"))
--    if not level.map_has_object_spot(obj.id,"treasure") then
      level.map_add_object_spot_ser(obj.id, "treasure", text)
--    else
--      amk.mylog("Blocking mapspot for "..obj:name())
--    end

	-- проверка, какой тип тайника выбран
		-- если тайник не классический и не именной, то заменим содержимое
		if game_options.AmkTrs ~= 0 and v.named == false then
		   v.items = self:give_item_list()
		else
			v.items = parse_items(self.ini:r_list(k, "items"))
		end  
		
		--' Сгенерить вещи
		for kk,vv in pairs(v.items) do
				for i=1,vv.prob do
					alife():create(vv.section,
							obj.position,
							obj.m_level_vertex_id,	
							obj.m_game_vertex_id,
							obj.id)
				end
		end
		
		--' Пометим тайник как выданный
		self.treasure_info[k].active = true
		self.treasure_info[k].done = true
    -- Отправим тайник в оффлайн
    local sim = alife ()
    if sim ~= nil and obj.online then
       sim:set_switch_online  (obj.id, false)
       sim:set_switch_offline (obj.id, true)
--       sim:set_switch_online  (obj.id, true)
--       sim:set_switch_offline (obj.id, false)
       amk.convert_npc[obj.id]=1 -- ставим в очередь на вывод в онлайн
    end
	else
		printf("TREASURE %s, target doesnt exist", k)
	end
end
--' Снимаем отметку с тайника
function CTreasure:treasure_empty(box, box_story_id)
	printf("!!! treasure empty")
	local k = self.treasure_by_target[box_story_id]

	if k == nil or self.treasure_info[k] == nil then 
		return
	end

	if self.treasure_info[k].active then
		self.treasure_info[k].active = false
		actor_stats.add_points("treasures", level.name(), 1, 1)
	end
	
	-- если тайник не именной, то переведен его в онлайн для следующей выдачи
	if self.treasure_info[k].named == false then
	  self.treasure_info[k].done = false
	end
	
	level.map_remove_object_spot(box:id(), "treasure")
end
--' Сохранение
function CTreasure:save(p)
	--' Сохраняем размер таблицы
	local size = 0
	for k,v in pairs(self.treasure_info) do
		-- пишем состояние только активных тайников
		if v.active or v.done then
			size = size + 1
		end
	end
	p:w_u16(size)
	for k,v in pairs(self.treasure_info) do
		if v.active or v.done then
			p:w_u16(v.target)
			p:w_bool(v.active)
			p:w_bool(v.done)
		end
	end
end
--' Загрузка
function CTreasure:load(p)
	local t = p:r_u16()
	for i = 1,t do
		local k = self.treasure_by_target[p:r_u16()]
		self.treasure_info[k].active = p:r_bool()
		self.treasure_info[k].done = p:r_bool()
	end
end

function CTreasure:give_item_list()
	local ret = {}
	local rnd = math.random
	-- сколько наименований предметов будет в тайнике
	local i = rnd(1, 4)

	-- определим ранг непися
	if n_rank == nil then n_rank = rnd(1, 12)*100 end
	local rank = ranks.get_rank_name_by_val( n_rank, true )

	-- определим, из какой секции брать предметы, и какие именно  
	local tbl
	if game_options.AmkTrs == 1 then
		tbl = solid_list[rank.."_section"]
	else
		tbl = rare_list[rank.."_section"]
	end
	
	local cnt = 0
	local s, cls = "", ""
	for j = 1, i, 1 do
		s = tbl[rnd(#tbl)]

		-- установка кол-ва предметов в зависимости от секции
		cls = sys_ini:r_string(s, "class")
		if ammo_section(s) == true then
			-- патроны
			cnt = rnd(1,3)
		elseif cls == "E_STLK" or cls == "W_SILENC" or cls == "W_GLAUNC"
			or string.find(cls, "WP_")
		then
			-- броники, оружие
			cnt = 1
		elseif string.find(s, "af") ~= nil
			or sys_ini:r_bool_ex(s, "monster_part")
		then
			cnt = rnd(1,2)
		else 
			cnt = rnd(1,5)
		end
  
		-- сохраняем инфу о текущем предмете
		table.insert(ret, {section = s, prob = cnt})
	end
	return ret
end

function get_treasure_manager()
	if treasure_manager == nil then
		treasure_manager = CTreasure()
	end
	return treasure_manager
end

function take_item_from_box(box, box_story_id)
	if box_story_id == nil then return end
	get_treasure_manager():treasure_empty(box, box_story_id)
end

function save(p)
	get_treasure_manager():save(p)
end
function load(p)
	get_treasure_manager():load(p)
end
function clear_treasure_manager()
	treasure_manager = nil
end

function CTreasure:dialog(npc)
	if npc ~= nil then
	  n_rank = npc:character_rank()
	 else 
      n_rank = 0
	end
	local avail = {}
	local tr_sum = 0
	local treasure_prob
	
	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false then
			--local treasure_prob = xr_logic.pick_section_from_condlist(db.actor, npc, v.condlist)
			treasure_prob = xr_logic.pick_section_from_condlist(db.actor, npc, xr_logic.parse_condlist(db.actor, "treasure_manager", "condlist", utils.cfg_get_string(self.ini, k, "condlist", nil, true, "")))
			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end
			if tonumber(treasure_prob) >= 0 and v.active == false then
				if tonumber(treasure_prob) == 100 then
					self:give_treasure(k)
				else
					table.insert(avail, {k = k, prob = treasure_prob})
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end
	if tr_sum == 0 then
		return
	end
	local tr_w = math.random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			self:give_treasure(v.k)
			break
		end
	end
end
