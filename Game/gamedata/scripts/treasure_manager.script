-- -*- mode: lua; encoding: windows-1251 -*-
-- solid_list основан на Linspiro Addon v1.1


local rare_list = {

 novice_section = {
 "wpn_toz34",
 "wpn_ak74",
 "wpn_mp5_m1",
 "wpn_colt_m1",
 "wpn_mp5_m2",
 "wpn_walther_m1",
 "wpn_fort_m1",
 "scientific_outfit",
 "stalker_outfit_v3",
 "specops_outfit",
 "dolg_gaz_outfit_m1",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "mutant_flesh_eye",		
 "mutant_boar_leg",		
 "mutant_dog_tail",		  			
 "mutant_zombie_hand",		
 "mutant_face_tushkano",		
 "mutant_tail_cat",				   
 "mutant_spleen_rat",
 "mutant_plague_hand",
 "af_medusa",
 "af_vyvert",
 "af_blood",
 "af_electra_sparkler",
 "af_rusty_thorn",
 "af_ameba_slime",
 "af_drops",      	
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_electra_moonlight",
 "af_gravi",
 "af_cristall_flower",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 "medkit",
 "outfit_soldier_m1",
 "neytral_novice_outfit_m1",
 "neytral_novice_outfit_new",
 "neytral_novice_outfit_cam_1",
 "neytral_novice_outfit_cam_2",
 "neytral_novice_outfit_cam_3",
 "bandit_outfit",
 "bandit_outfit_blue",
 "bandit_outfit_red",
 "mushroom",
 "fake_wpn_knife",
 "sigaret",
 "ammo_9x19_pbp",
 "ammo_11.43x23_hydro",
 "ammo_zhekan_izomorf",
 "mutant_tushkano_cocoon",
 "mutant_dog_cocoon",
 "mutant_psevdodog_cocoon",
 "mutant_flesh_cocoon",
 "mutant_cat_cocoon",
 "mutant_boar_cocoon",
 "grenade_gd-05"
  },

 experienced_section = {
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "ammo_og-7b",
 "ammo_5.45x39_izomorf",
 "ammo_7.62x39_ap",
 "ammo_7.62x51box",
 "mutant_zombie_hand",
 "mutant_snork_leg",				
 "mutant_poltergeist_glas",				
 "mutant_fracture_hand", 
 "mutant_boar_leg",
 "mutant_carlic_hand",
 "part_tarakan_strong",
 "mutant_vypolzen_hrebet",
 "wpn_m16a2_sk1",
 "wpn_sg552_sk1",
 "wpn_wincheaster1300",
 "wpn_m4",
 "wpn_ppsh41_sk2",
 "wpn_abakan_m1",
 "wpn_fort_m1",
 "wpn_winchester_m1",
 "wpn_l85_m1",
 "wpn_l85_m2",
 "wpn_beretta_m1",
 "military_outfit",
 "svoboda_heavy_outfit",
 "dolg_scientific_outfit",
 "freedom_scientific_outfit",
 "merc_scientific_outfit",
 "monolit_scientific_outfit",
 "nebo_scientific_outfit",
 "outfit_dolg_m1",
 "outfit_killer_m1",
 "af_fuzz_kolobok",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_soul",
 "af_night_star",
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_babka_1",
 "af_spirit_1",
 "medkit_army",
 "mutant_zombie_cocoon",
 "mutant_snork_cocoon",
 "mutant_poltergeist_cocoon",
 "amk_kanistra",
 "grenade_flash",
 "acumm"
 },

 veteran_section = {
 "af_dummy_dummy",
 "af_fuzz_kolobok",
 "af_spirit_1",        
 "af_spirit_2",       
 "af_cry_1",
 "af_babka_1",
 "af_pudd_1",
 "af_pudd_2",
 "af_dik_1",
 "af_kol_1",
 "af_armor_1",
 "af_armor_2",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_eye_voron",
 "ammo_og-7b",
 "ammo_vog-25p",	
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_5.45x39_fmj",
 "ammo_9x39_pab9",
 "ammo_9x39_ap",
 "ammo_9x39_sp5",
 "ammo_9x39_izomorf",
 "ammo_minigun",
 "ammo_5.56x45_ap",
 "ammo_20x85",
 "ammo_7.62x51_ap",
 "ammo_gauss",
 "nebo_exo_outfit",
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",
 "mutant_zombie_hand",	
 "mutant_hand_kontroler",			
 "mutant_psevdogigant_hand",			
 "mutant_chimera_kogot",
 "mutant_spider_gland",
 "mutant_rotan_heart",
 "mutant_zanoza_leg",
 "wpn_spas12",
 "wpn_m1891_30_scope",
 "wpn_groza",
 "medkit_scientic",
 "mutant_krovosos_cocoon",
 "mutant_burer_cocoon",
 "mutant_chimera_cocoon",
 "amk_ballon",
 "grenade_flash",
 "grenade_gd-05",
 "ekza_akkumul"
 },

master_section = {
 "wpn_spas12",
 "wpn_groza",
 "wpn_val_m1",
 "wpn_protecta",	
 "wpn_mp5k_pdw57",
 "wpn_mp5k_pdw_tt",
 "wpn_g3_otdaca_ves",
 "mutant_krovosos_jaw",		
 "mutant_burer_hand",		
 "mutant_hand_kontroler",				
 "mutant_psevdogigant_hand",					
 "mutant_chimera_kogot",
 "mutant_deathclaw_antler",
 "mutant_raptor_kogot",
 "mutant_plague_hand",
 "mozg",
 "ammo_7.62x54_7h1",
 "ammo_7.62x54_ap",
 "ammo_7.62x54_7h14",
 "ammo_12x70_buck",
 "ammo_og-7b",
 "grenade_rgd5",
 "ammo_7.62x54_izomorf",
 "ammo_7.62x39_k",
 "ammo_7.62x54r",
 "ammo_357_ap_mag",
 "ammo_12.7x108r",
 "ammo_balon",
 "ammo_12.7x108",
 "ammo_super_gauss",
 "svoboda_exoskeleton",
 "nebo_exo_outfit",
 "exo_bandit_outfit",
 "voen_exo_outfit",
 "exo_scientist_outfit",
 "exo_outfit",
 "dolg_black_exoskeleton",
 "killer_green_exoskeleton",
 "seva_scient_outfit",
 "af_simbion",        
 "af_spirit_2",         
 "af_cry_2",
 "af_babka_2",
 "af_pudd_2",
 "af_babka_3",
 "af_dik_2",
 "af_kol_2",
 "af_kol_3",
 "af_armor_2", 
 "af_armor_3",
 "suvorotka",
 "medkit_scientic",
 "mutant_gigant_cocoon",
 "mutant_controller_cocoon",
 "ekza_akkumul",
 "acumm"
 }
}

local solid_list = {
 novice_section = {
 --Артефакты--
 "af_drops",
 "af_ameba_slime",
 "af_rusty_thorn",
 "af_electra_sparkler",
 "af_blood",
 "af_vyvert",
 "af_medusa",
 --Аммуниция--
 "grenade_rgd5",
 "ammo_12x70_buck",     
 "ammo_9x19_fmj",
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_9x18_fmj",
 --Оружие--
 "wpn_addon_silencer",
 "wpn_mp5",
 "wpn_bm16",
 "wpn_fort",
 "wpn_pb",
 "wpn_pm",
 --Прочее--
 "bread",
 "bandage",
 "kolbasa",
 "medkit",
 "vodka",
 "sigaret",
 "conserva",
 "grenade_gd-05"
 },

experienced_section = {
--Артефакты--
 "af_cristall_flower",
 "af_gravi",
 "af_mincer_meat",
 "af_electra_flash",
 "af_rusty_kristall",
 "af_ameba_slug",
 "af_fireball",
 --Аммуниция--
 "grenade_rgd5",
 "grenade_gd-05",
 "grenade_flash",
 "grenade_f1",     
 "ammo_9x19_pbp",
 "ammo_9x18_pmm",
 "ammo_5.45x39_fmj",
 "ammo_11.43x23_fmj",
 "ammo_5.56x45_ss190",
 --Пушки--
 "wpn_addon_scope",
 "wpn_mp5",
 "wpn_ak74u",
 "wpn_ak74u_m1",
 "wpn_walther",
 --Прочее--
 "mutant_dog_tail",
 "mutant_boar_leg",
 "kolbasa",
 "medkit",
 "antirad",
 "energy_drink",
 "conserva",
 "grenade_flash",
 "acumm"
 },

 veteran_section = {
 --Артефакты--
 "af_night_star",
 "af_gold_fish",
 "af_soul",
 "af_electra_moonlight",
 "af_rusty_sea-urchin",
 "af_ameba_mica",
 "af_cristall",
 --Аммуниция--
 "grenade_f1",
 "ammo_vog-25",     
 "ammo_m209",
 "ammo_5.45x39_ap",
 "ammo_11.43x23_hydro",
 "ammo_9x39_pab9",
 "ammo_5.56x45_ss190",
 "ammo_12x76_zhekan",
 --Пушки--
 "wpn_addon_scope_susat",
 "wpn_addon_grenade_launcher",
 "wpn_beretta",
 "wpn_sig550",
 "wpn_toz34",
 "wpn_abakan_m2",
 "wpn_desert_eagle",
 --Прочее--
 "mutant_psevdodog_tail",
 "mutant_snork_leg",
 "medkit_army",
 "antirad",
 "grenade_gd-05",
 "grenade_flash",
 "acumm"
 },

 master_section = {
 --Артефакты--
 "af_dummy_glassbeads",
 "af_dummy_pellicle",
 "af_dummy_battery",
 "af_dummy_dummy",
 "af_dummy_spring",
 "af_fuzz_kolobok",
 --Аммуниция--
 "ammo_m209",
 "ammo_vog-25p",     
 "ammo_9x39_ap",
 "ammo_12x76_dart",
 "ammo_7.62x54_7h14",
 "ammo_9x39_sp5",
 "ammo_5.56x45_ap",
 "ammo_7.62x54_7h1",
 --Пушки--
 "wpn_addon_grenade_launcher_m203",
 "wpn_colt1911",
 "wpn_spas12",
 "wpn_l85",
 "wpn_lr300",
 "wpn_groza",
 "wpn_groza_m1",
 --Прочее--
 "mutant_krovosos_jaw",
 "mutant_burer_hand",
 "medkit_army",
 "medkit_scientic",
 "ekza_akkumul"
 }
}

local treasure_manager = nil

function parse_items(t)
	if t == nil then
		return {}
	end

	local n = table.getn(t)
		
	local ret_table = {}
	local k = 1

	while k <= n do
		local spawn = {}
		spawn.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			-- проверяем что вторым числом задана вероятность, а не другая секция спавну
			if p then
				-- забиваем число
				spawn.prob = p
				k = k + 2
			else
				-- забиваем дефолт 1
				spawn.prob = 1
				k = k + 1
			end
		else
			spawn.prob = 1
			k = k + 1
		end
		table.insert(ret_table, spawn)
	end
	return ret_table
end


class "CTreasure"
function CTreasure:__init()
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	self.ini = ini_file("misc\\treasure_manager.ltx")

	--' Итерируемся по всем настройкам фраз
	if not self.ini:section_exist("list") then
		abort("There is no section [list] in treasure_manager.ltx")
	end
	
	local n = self.ini:line_count("list")
	local result, id, value = 0,"",""

	--' начальная установка
	self.treasure_info = {}

	for i=0,n-1 do
		result, id, value	= self.ini:r_line("list",i,"","")

		self.treasure_info[id] = {}
		local t = self.treasure_info[id]

		t.target		= self.ini:r_u32(id, "target")
		t.named			= self.ini:r_bool_ex(id, "named", false)
		t.name			= self.ini:r_string(id, "name")
		--' Отметим тайник как новый
		t.active = false
		t.done = false

		if t.target > 65535 then	-- вдруг забуду
			log("[CTreasure:__init]: treasure %s story_id [%s]: it more than 65535! It cannot be saved!", id, t.target)
		end
		--print_table(self.treasure_info)
	end

	--' Вспомогательные таблицы для облегчения поиска
	self.treasure_by_target = {}
	for k,v in pairs(self.treasure_info) do
		self.treasure_by_target[v.target] = k	
	end

	self.used_npc = {}
end
--' Юзание инициатора (возможность выдать тайник)
function CTreasure:use(npc)
--	printf("TREASURE USE")
	local npc_id = npc:id()
	if self.used_npc[npc_id] then
		return
	end
	self.used_npc[npc_id] = true

	local se_obj = AI:object(npc_id)
	if se_obj==nil or se_obj.treasure_processed == true then return end
	se_obj.treasure_processed = true

	if npc:object("device_pda_npc") == nil then
		return
	end

	lootmoney.lootmoney(npc)

	if npc ~= nil then
		self.npc_rank = npc:character_rank()
	else 
		self.npc_rank = nil
	end

	local rarets
	-- если выбран редкий тип тайников, то снизим вероятность его выпадения
	if game_options.AmkTrs == 2 then 
		rarets = 88
	else 
		rarets = 70
	end

	if math.random(100) < rarets then 
		return
	end

	--' Нужно рандомно выбрать один из тайников.
	local avail = {}
	local tr_sum = 0
	local treasure_prob

	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false then
			--local treasure_prob = xr_logic.pick_section_from_condlist(Actor, npc, v.condlist)
			treasure_prob = xr_logic.pick_section_from_condlist(Actor, npc,
				xr_logic.parse_condlist(Actor, "treasure_manager", "condlist", self.ini:r_string_ex(k, "condlist", ""))
			)

			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end

			if tonumber(treasure_prob) >= 0 then
				if tonumber(treasure_prob) == 100 then
					self:give_treasure(k)
				else
					table.insert(avail, {k = k, prob = treasure_prob})
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end

	if tr_sum == 0
		or math.random(100) < 50
	then
		return
	end

	local tr_w = math.random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			--' Выдать тайник
			self:give_treasure(v.k)
			break
		end
	end
end
--' Сохранение
function CTreasure:check()
	--' Проверка тайников
	for k,v in pairs(self.treasure_info) do
		--' Выдать тайник
		self:give_treasure(k)
	end
end
--' Напоминания об активных тайниках на текущей территории
function CTreasure:remind()
	local obj
	local have = false
	local text = "%c[255,255,120,160]Тайники:\\n%c[190,200,200,200]"
	
	for k,v in pairs(self.treasure_info) do
		if v.active then
			obj = AI:story_object(v.target)
			if obj and GGraph:vertex(obj.m_game_vertex_id):level_id() == AI:level_id() then
				text = text..game.translate_string(v.name).."\\n"
				have = true
			end
		end
	end
	
	if have then
		reminder.send_info(text)
	end
end
--' Выдача тайника
function CTreasure:give_treasure(k)
	local v = self.treasure_info[k]
	local obj = AI:story_object(v.target)
	if obj ~= nil then
		if obj:clsid() ~= clsid.inventory_box then
			abort("Story object [%s] is not an inventory box", v.target)
		end

		local lname = object_level_name(obj)
		news_manager.send_treasure(v.name, lname)

		--' Пометить на карте		
		local text = "%c[255,238,155,23]"..game.translate_string(v.name).."\\n"..
			"%c[default]"..game.translate_string(self.ini:r_string(k, "description"))

		if level.map_has_object_spot(obj.id, "treasure") == 0 then
			level.map_add_object_spot_ser(obj.id, "treasure", text)
		else
			log("~ Treasure %s[%s] already has mapspot", k, obj:name())
		end

		-- проверка, какой тип тайника выбран
		-- если тайник не классический и не именной, то заменим содержимое
		if game_options.AmkTrs ~= 0 and v.named == false then
		   v.items = self:give_item_list()
		else
			v.items = parse_items(self.ini:r_list(k, "items"))
		end  
		
		--' Сгенерить вещи
		for kk,vv in pairs(v.items) do
			for i=1,vv.prob do
				AI:create(vv.section,
						obj.position,
						obj.m_level_vertex_id,	
						obj.m_game_vertex_id,
						obj.id)
			end
		end

		--' Пометим тайник как выданный
		v.active = true
		v.done = true
		-- Отправим тайник в оффлайн
		if AI ~= nil and obj.online then
			AI:set_switch_online  (obj.id, false)
			AI:set_switch_offline (obj.id, true)
			amk.convert_npc[obj.id]=1 -- ставим в очередь на вывод в онлайн
		end
	else
		log("! TREASURE %s, target doesnt exist", k)
	end
end
--' Снимаем отметку с тайника
function CTreasure:treasure_empty(box, box_story_id)
--	printf("!!! treasure empty")
	local k = self.treasure_by_target[box_story_id]

	if k == nil or self.treasure_info[k] == nil then 
		return
	end

	local v = self.treasure_info[k]
	if v.active then
		v.active = false
		actor_stats.add_points("treasures", v.name, 1, 1)
	end

	-- если тайник не именной, то переведен его в онлайн для следующей выдачи
	if v.named == false then
		v.done = false
	end

	level.map_remove_object_spot( box:id(), "treasure" )
end
--' Сохранение
function CTreasure:save(p)
	--' Сохраняем размер таблицы
	local size = 0
	for k,v in pairs(self.treasure_info) do
		-- пишем состояние только активных тайников
		if v.active or v.done then
			size = size + 1
		end
	end
	p:w_u16(size)
	for k,v in pairs(self.treasure_info) do
		if v.active or v.done then
			p:w_u16(v.target)
			p:w_bool(v.active)
			p:w_bool(v.done)
		end
	end
end
--' Загрузка
function CTreasure:load(p)
	local t = p:r_u16()
	for i = 1,t do
		local k = self.treasure_by_target[p:r_u16()]
		self.treasure_info[k].active = p:r_bool()
		self.treasure_info[k].done = p:r_bool()
	end
end

function CTreasure:give_item_list()
	local ret = {}
	local rnd = math.random
	-- сколько наименований предметов будет в тайнике
	local i = rnd(1, 4)

	-- определим ранг непися
	if self.npc_rank == nil then self.npc_rank = rnd(1, 12)*100 end
	local rank = ranks.get_rank_name_by_val( self.npc_rank, true )

	-- определим, из какой секции брать предметы, и какие именно  
	local tbl
	if game_options.AmkTrs == 1 then
		tbl = solid_list[rank.."_section"]
	else
		tbl = rare_list[rank.."_section"]
	end
	
	local cnt = 0
	local s, cls = "", ""
	for j = 1, i, 1 do
		s = table.random(tbl)

		-- установка кол-ва предметов в зависимости от секции
		cls = sys_ini:r_clsid(s, "class")
		if ammo_sections[s] then
			-- патроны
			cnt = rnd(1,3)
		elseif isOutfit(nil, cls) or rx_addons.item_is_addon(nil, cls)
			or isWeapon(nil, cls)
		then
			-- броники, оружие
			cnt = 1
		elseif isArtefact(nil, cls)
			or sys_ini:r_bool_ex(s, "monster_part")
		then
			cnt = rnd(1,2)
		else 
			cnt = rnd(1,4)
		end
  
		-- сохраняем инфу о текущем предмете
		table.insert(ret, {section = s, prob = cnt})
	end
	return ret
end

function CTreasure:dialog(npc)
	if npc ~= nil then
		self.npc_rank = npc:character_rank()
	else 
		self.npc_rank = nil
	end

	local avail = {}
	local tr_sum = 0
	local treasure_prob
	
	for k,v in pairs(self.treasure_info) do
		if v.done == false and v.active == false then
			--local treasure_prob = xr_logic.pick_section_from_condlist(Actor, npc, v.condlist)
			treasure_prob = xr_logic.pick_section_from_condlist(
				Actor, npc,
				xr_logic.parse_condlist(
					Actor, "treasure_manager", "condlist",
					self.ini:r_string_ex(k, "condlist", "")
				)
			)
			if treasure_prob == "" or treasure_prob == nil then
				treasure_prob = 0
			end
			if tonumber(treasure_prob) >= 0 then
				if tonumber(treasure_prob) == 100 then
					self:give_treasure(k)
				else
					table.insert(avail, {k = k, prob = treasure_prob})
					tr_sum = tr_sum + treasure_prob
				end
			end
		end
	end
	if tr_sum == 0 then
		return
	end
	local tr_w = math.random(tr_sum)
	for k,v in pairs(avail) do
		tr_w = tr_w - v.prob
		if tr_w <= 0 then
			self:give_treasure(v.k)
			break
		end
	end
end

-----------------------------------------------------------------------------------------
function get_treasure_manager()
	if treasure_manager == nil then
		treasure_manager = CTreasure()
	end
	return treasure_manager
end

function take_item_from_box(box, box_story_id)
	if box_story_id == nil then return end
	get_treasure_manager():treasure_empty(box, box_story_id)
end

function save(p)
	get_treasure_manager():save(p)
end
function load(p)
	get_treasure_manager():load(p)
end
function clear_treasure_manager()
	treasure_manager = nil
end

function is_active_treasure(box_story_id)
	local mgr = get_treasure_manager()
	local k = mgr.treasure_by_target[box_story_id]
	if not k then return false end

	if mgr.treasure_info[k] and mgr.treasure_info[k].active then
		return true
	end

	return false
end

function give_random_tresure()
	local mgr = get_treasure_manager()
	local tmp = {}
	for k, v in pairs(mgr.treasure_info) do
		if not (v.active or v.done or v.named) then
			table.insert(tmp, k)
		end
	end
	mgr.npc_rank = math.random(400,1000)
	mgr:give_treasure( table.random(tmp) )
end
