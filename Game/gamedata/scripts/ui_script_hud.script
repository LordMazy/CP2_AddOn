-- -*- mode: lua; encoding: windows-1251 -*-
-- Options
local show_npc = true
local show_enemy = false
local show_corpse = true
local show_gps = true
local show_treasures = true
local show_lc = true
local show_time = true
local show_quick_slots = false
local biodetector_mode = false
---------------------------------------------------------------------------
local bind_to_show = key_bindings.kSCORES
local dev = device()
local has_spot = level.map_has_object_spot
local math_cos = math.cos
local math_sin = math.sin
local table_insert = table.insert

local spot_size_12    = vector2():set(12*kScreen, 12)
local spot_size_16    = vector2():set(16*kScreen, 16)
local spot_size_npc   = vector2():set(3*kScreen, 3)
local spot_offset_12  = vector2():set(spot_size_12.x/2, spot_size_12.y/2)
local spot_offset_16  = vector2():set(spot_size_16.x/2, spot_size_16.y/2)
local spot_offset_npc = vector2():set(spot_size_npc.x/2, spot_size_npc.y/2)

local wnd = nil

local step_angle = 1.5/(180/math.pi) -- шаг за апдейт в радианах (скорость поворота)
local two_pi = 2*math.pi

local map_zoom = 2
local map_dist = 150/map_zoom

local detector = nil

local added_spots = {}
---------------------------------------------------------------------------
class "UIScriptHUD" (CUIWindow)

function UIScriptHUD:__init()
	super()

	self.biodetector_mode = false
	self.sweep_angle = 0

	self.is_break = false

	self:Init(0, 0, 1024, 768)

	local xml = CScriptXmlInit()
	xml:ParseFile("ui_script_hud.xml")

	local ini = game_ini()
	local level_name = level.name()
	self.map_texture = ini:r_string_ex(level_name, "texture", "ui\\ui_nomap2")

	self.bound_rect = ini:r_rect(level_name, "bound_rect")
		or Frect():set(10000, 10000, -10000, -10000)

	self.map_frame = xml:InitStatic("level_frame", self)
	self.map_frame:ClipperOn()
	self.clip_center = vector2():set( self.map_frame:GetWidth()/2, self.map_frame:GetHeight()/2 )

	self.map = xml:InitStatic("level_map", self.map_frame)
	local w = self.bound_rect:width() *map_zoom
	local h = self.bound_rect:height() *map_zoom
	self.map:SetWndRect( 0, 0, w, h )
	self.map:InitTexture(self.map_texture)
	self.map_center = vector2():set( w/2, h/2 )

	self.sweep = xml:InitStatic("biodetector_sweep", self.map_frame)
	self.sweep:Show(false)

	local st = xml:InitStatic("minimap_center", self.map_frame)
	st:SetWndPos(
		self.clip_center.x - st:GetWidth()/2,
		self.clip_center.y - st:GetHeight()/2
	)
	self.minimap_center = st

	self.map_spots = {}
	self.del_spots = {}

	xml:InitStatic("background", self)

	self.body_state = xml:InitStatic("body_state", self)

	st = xml:InitStatic("static_power", self)
	self.progress_power = xml:InitProgressBar("power_progress", st)

	self.progress_luminosity = xml:InitProgressBar("luminosity_progress", st)
	self.progress_noise = xml:InitProgressBar("noise_progress", st)

	st = xml:InitStatic("static_health", self)
	self.progress_health = xml:InitProgressBar("progress_bar_health", st)

	st = xml:InitStatic("static_armor", self)
	self.progress_armor = xml:InitProgressBar("progress_bar_armor", st)

	st = xml:InitStatic("static_radiation", self)
	self.progress_radiation = xml:InitProgressBar("progress_bar_radiation", st)

	self.time_static = xml:InitStatic("time_static", self)

	xr_s.subscribe("update", self.Update, {self = self})
	self.need_update = false

	if has_alife_info("pda_biodetector_mode") then
		self:SwitchBioradar()
	elseif has_alife_info("pda_dont_work") then
		self:Break(true)
	end
end

function UIScriptHUD:__finalize()
end

function UIScriptHUD:Update(delta)
	if self.is_break then return end

	amk.oau_reason="UIScriptHUD:Update"
	amk.oau_watchdog=18810
	if biodetector_mode then
		self.sweep_angle = self.sweep_angle - step_angle*delta/20
		if self.sweep_angle < 0 then
			self.sweep_angle = self.sweep_angle + two_pi
		end
	end

	if not self.need_update then return end

	amk.oau_watchdog=18811
	self:UpdateIndicators()

	amk.oau_watchdog=18812
	self:UpdateMap()
end

function UIScriptHUD:UpdateIndicators()
	local str = get_body_state_str()
	if str then
		self.body_state:InitTexture("ui_hud_soldier_"..str)
	end

	self.progress_power:SetProgressPos( Actor.power * 100 )
	self.progress_health:SetProgressPos( Actor.health * 100 )

	if arc_inventory.IsRadDetected() then
		self.progress_radiation:SetProgressPos( 100 * math.min(arc_radiation.RAD_DOSE/arc_radiation.DOSE_DEADLY, 1) )
	else
		self.progress_radiation:SetProgressPos(0)
	end

	local outfit_id = -1
	if actor_outfit then
		self.progress_armor:SetProgressPos( actor_outfit:condition() * 100 )
		self.progress_noise:SetProgressPos( (actor_outfit:get_charge_level() or 0) * 100 )
		outfit_id = actor_outfit:id()
	elseif self.last_outfit_id ~= -1 then
		self.progress_armor:SetProgressPos(0)
		self.progress_noise:SetProgressPos(0)
	end

	local inv_weight = Actor:get_inventory_weight()
	if inv_weight ~= self.last_weight
		or outfit_id ~= self.last_outfit_id
	then
		self.last_weight = inv_weight
		self.last_outfit_id = outfit_id

		local max_weight = Actor:get_actor_max_weight()
		local max_walk_weight = Actor:get_actor_max_walk_weight()
		if actor_outfit then
			max_walk_weight = max_walk_weight + actor_outfit:get_additional_inventory_weight()
			max_weight = max_weight + actor_outfit:get_additional_inventory_weight2()
		end
		
		if inv_weight > max_weight then
			local k = (inv_weight - max_weight)/(max_walk_weight - max_weight)
			k = math.clamp(k, 0, 1)
			self.body_state:SetColor( GetARGB(
				255,
				math.min( k*510, 255 ),
				math.min( (1-k)*510, 255 ),
				0
			) )
		else
			self.body_state:SetColor( GetARGB(255,0,255,0) )
		end
	end

	local item = Actor:item_in_slot( inventory_slots.TORCH )
	local val = 0
	if item then
		val = item:get_charge_level() or 0
	end
	self.progress_luminosity:SetProgressPos( val * 100 )

	if show_time then
		self.time_static:SetText( string.format( "%02d:%02d", level.get_time_hours(), level.get_time_minutes() ) )
	end
end

function UIScriptHUD:UpdateMap()
	-- local t = profile_timer()
	-- t:start()

	self.map_angle = -dev.cam_dir:getH()

	-- Update map position
	self.map:SetHeading(self.map_angle)
	local pos = self:ConvertRealToLocal( Actor:position() )
	local new_pos = vector2()
	new_pos:sub(pos)
	new_pos:add(self.clip_center)
	self.map:SetWndPos( new_pos:get() )

	if biodetector_mode then
		self.sweep:SetHeading(self.sweep_angle)
	end

	-- t:stop()
	-- log("Update map position: %s", t:time())
	-- t:start()

	self:UpdateSpots()

	-- t:stop()
	-- log("Total: %s", t:time())
end

function UIScriptHUD:RemoveAllSpots()
	for id in pairs(self.map_spots) do
		table_insert(self.del_spots, id)
	end
	for i, v in ipairs(self.del_spots) do
		self.map:DetachChild( self.map_spots[v] )
		self.map_spots[v] = nil
	end
	self.del_spots = {}
end

local lc_clsid = clsid.level_changer
local inv_box_clsid = clsid.inventory_box
local mine_clsid = clsid.zone_mine_field_s
function UIScriptHUD:UpdateSpots()
	amk.oau_watchdog=18813
	-- удалим неактуальные метки
	for id, st in pairs(self.map_spots) do
		if db.for_map[id] == nil then
			table_insert(self.del_spots, id)
		end
	end
	for i, v in ipairs(self.del_spots) do
		self.map:DetachChild( self.map_spots[v] )
		self.map_spots[v] = nil
	end
	self.del_spots = {}

	amk.oau_watchdog=18814

	local spot, tex, sz, cls, sobj
	local actor_pos = Actor:position()

	for id, obj in pairs(db.for_map) do
		spot = self.map_spots[id]
		sobj = AI:object(id)
		if sobj and sobj.online
			and obj:position():distance_to_xz(actor_pos) < map_dist
		then
			amk.oau_reason="UIScriptHUD:UpdateSpots "..id
			tex, sz = nil, nil
			if not spot then
				if obj:is_entity_alive() then
					if not (obj:is_stalker() and sobj:visible_for_map()==false) then
						tex = "ui_minimap_point"
						sz = spot_size_npc
					end
				elseif not biodetector_mode then
					cls = obj:clsid()
					if cls == inv_box_clsid then
						if show_gps and gps_habar.has_label(id) then
							tex = get_GPS_texture(id)
						elseif show_treasures and has_spot(id, "treasure")~=0 then
							tex = "ui_mapPDA_treasure"
						end
						sz = spot_size_12
					elseif cls == lc_clsid then
						if show_lc and check_lc_spot(id) then
							tex = "ui_mapPDA_level_changer5"
							sz = spot_size_16
						end
					elseif IsAnomaly(nil, cls) and detector then
						tex = get_anom_texture(id)
						sz = spot_size_16
					elseif cls == mine_clsid and has_spot(id, "anomaly_mine_location") ~= 0 then
						tex = "anomaly_mine"
						sz = spot_size_16
					end
					if ( not (tex and sz) ) and added_spots[id] then
						tex = added_spots[id]
						sz = spot_size_12
					end
				end
				if tex and sz then
					self.map_spots[id] = self:DrawSpot( obj, tex, sz:get() )
				end
			else
				if obj:is_entity_alive() then
					if not (obj:is_stalker() and sobj:visible_for_map()==false) then
						local clr = get_point_color(obj)
						if clr then
							spot:SetWndPos( self:ConvertRealToLocal( obj:position() ):sub(spot_offset_npc):get() )
							spot:SetColor(clr)
						else
							table_insert(self.del_spots, id)
						end
					end
				elseif biodetector_mode then
					table_insert(self.del_spots, id)
				else
					cls = obj:clsid()
					if cls == inv_box_clsid then
						sz = spot_offset_12
					elseif (cls == lc_clsid) then
						sz = spot_offset_16
					elseif IsAnomaly(nil, cls) or cls == mine_clsid then
						if has_spot(id, spot.spot_name) ~= 0 then
							sz = spot_offset_16
						end
					end
					if (not sz) and added_spots[id] then
						sz = spot_offset_12
					end
					if sz then
						spot:SetWndPos( self:ConvertRealToLocal( obj:position() ):sub(sz):get() )
					else
						table_insert(self.del_spots, id)
					end
				end
			end
		elseif spot then
			table_insert(self.del_spots, id)
		end
	end

	amk.oau_watchdog=18815
end

function UIScriptHUD:ConvertRealToLocal(pos)
	local res = vector2()
	res.x = (pos.x - self.bound_rect.x1) *map_zoom
	res.y = ( self.bound_rect:height() - (pos.z - self.bound_rect.y1) ) *map_zoom

	res:sub(self.map_center)
	rotation(res, self.map_angle)
	res:add(self.map_center)

	return res
end

function UIScriptHUD:DrawSpot(obj, tex, w, h)
	if tex == nil then return  nil end

	local clr
	if tex == "ui_minimap_point" then
		clr = get_point_color(obj)
		if not clr then
			return nil
		end
	end

	local pos = self:ConvertRealToLocal( obj:position() )

	local st = CUIStatic()
	st:Init(tex, pos.x-w/2, pos.y-h/2, w, h)
	st:SetAutoDelete(true)
	st:SetStretchTexture(true)
	if clr then
		st:SetColor(clr)
	end
	self.map:AttachChild(st)
	st:Show(true)
	st.spot_name = get_spot_by_texture(tex)

	return st
end

function UIScriptHUD:Break(mode)
	if self.is_break == mode then return end
	self.is_break = mode

	if mode then
		self.map:InitTexture("abc\\hud_empty")
		self.map_frame:InitTexture("ui\\ui_bsod")
		self.map_frame:SetOriginalRect(0, 0, 1024, 576)
		self.sweep:Show(false)
		self.time_static:SetText("")
		self.minimap_center:Show(false)
	else
		self.minimap_center:Show(true)
		self:SetPDAMode(self.biodetector_mode)
	end
end

function UIScriptHUD:SwitchBioradar()
	if not show_time then
		self.time_static:SetText("")
	end

	if self.biodetector_mode == biodetector_mode then return end
	self.biodetector_mode = biodetector_mode

	self:SetPDAMode(biodetector_mode)
end

function UIScriptHUD:SetPDAMode(is_biodetector)
	if is_biodetector then
		self.map:InitTexture("abc\\hud_empty")
		self.map_frame:InitTexture("intro\\intro_back")
		self.sweep:Show(true)
	else
		self.map:InitTexture(self.map_texture)
		self.map_frame:InitTexture("abc\\hud_empty")
		self.sweep:Show(false)
	end
end

function UIScriptHUD:RemoveSpot(obj_id)
	table_insert(self.del_spots, obj_id)
end
---------------------------------------------------------------------------
function get_level_bound_rect()
	local vol = level.get_bounding_volume()
	return Frect():set(
		vol.min.x,
		vol.min.z,
		vol.max.x,
		vol.max.z
	)
end
-- флажки состояния тела актера
local body_states = {
	current		= -1,
	fwd			= 1,
	back		= 2,
	l_strafe	= 4,
	r_strafe	= 8,
	crouch		= 16,
	accel		= 32,
	turn		= 64,
	jump		= 128,
	fall		= 256,
	landing		= 512,
	landing2	= 1024,
	climb		= 2048,
	sprint		= 4096,
	l_lookout	= 8192,
	r_lookout	= 16384
}
body_states.any_move = body_states.fwd + body_states.back + body_states.l_strafe + body_states.r_strafe

function get_body_state_str()
	local state = Actor:actor_body_state()

	if body_states.current == state then
		return nil
	end
	body_states.current = state

	if bit_and(state, body_states.climb) ~= 0 then
		return "climb"
	else
		if bit_and(state, body_states.crouch) ~= 0 then
			if bit_and(state, body_states.accel) ~= 0 then
				return "creep"
			else
				return "crouch"
			end
		else
			if bit_and(state, body_states.sprint) ~= 0 then
				return "sprint"
			else
				if bit_and(state, body_states.any_move) ~= 0
					and bit_and(state, body_states.accel) == 0
				then
					return "run"
				else
					return "normal"
				end
			end
		end
	end
end

local spot2texture = {
	gps = {
		gps_stalker					= "ui_mapPDA_gps_stalker",
		habar_location				= "ui_mapPDA_habar_small",
		habar_location_w			= "ui_icons_mapPDA_habar_small_w",
		habar_clear_location		= "ui_mapPDA_habar_clear",
		habar_clear_location_w		= "ui_icons_mapPDA_habar_clear_small_w"
	},
	anom = {
		anomaly_zone_location		= "anomaly_zone",
		anomaly_bald_location		= "anomaly_bald",
		anomaly_minc_location		= "anomaly_mincer",
		anomaly_grav_location		= "anomaly_gravi",
		anomaly_rad_location		= "anomaly_radiation",
		anomaly_elec_location		= "anomaly_electra",
		anomaly_mine_location		= "anomaly_mine",
		anomaly_burn_location		= "anomaly_burn",
		anomaly_ice_location		= "anomaly_ice",
		anomaly_ameba_location		= "anomaly_ameba",
		anomaly_buzz_location		= "anomaly_buzz_green",
		anomaly_sakbuzz_location	= "anomaly_fireball",
		anomaly_fountain_location	= "anomaly_fountain",
		anomaly_sphere_location		= "anomaly_sphere",
		anomaly_smallrain_location	= "anomaly_smallrain"
	}
}
local texture2spot = {}
for k, t in pairs(spot2texture) do
	for spot, tex in pairs(t) do
		texture2spot[tex] = spot
	end
end

function get_GPS_texture(obj_id)
	for k, v in pairs(spot2texture.gps)do
		if has_spot(obj_id, k) ~= 0 then
			return v
		end
	end
	return nil
end
function get_anom_texture(obj_id)
	for k, v in pairs(spot2texture.anom)do
		if has_spot(obj_id, k) ~= 0 then
			return v
		end
	end
	return nil
end
function get_spot_by_texture(tex)
	return texture2spot[tex]
end

function check_lc_spot(obj_id)
	for i = 1, 5 do
		if has_spot(obj_id, "level_changer"..i) ~= 0 then
			return true
		end
	end
	return false
end

function set_detector(det)
	if det == "detector_elite"
		or det == "detector_elite_sak"
		or det == "detector_elite_john"
		or det == "detector_suit"
	then
		detector = det
	else
		detector = nil
	end
end

local id2color = {
	[0] = GetARGB(255,255,0,0),		-- enemy
	[1] = GetARGB(255,255,200,0),	-- neutral
	[2] = GetARGB(255,50,255,0),	-- friend
	[3] = GetARGB(255,168,168,168)	-- corpse
}
function get_point_color(obj)
	if biodetector_mode then
		local clr = biodetector.getColor(obj)
		return clr and GetARGB( 255, unpack(clr) ) or nil
	end

	if not show_npc then
		return nil
	end

	local colorID

	if IsHuman[obj:clsid()] then
		if obj:character_community() == "zombied" then
			return nil
		end
		if obj:alive() then
			local rel = obj:relation(Actor)
			if rel == game_object.friend then
				colorID = 2
			elseif rel == game_object.neutral then
				colorID = 1
			elseif show_enemy and rel == game_object.enemy then
				colorID = 0
			else
				return nil
			end
		elseif show_corpse then
			colorID = 3
		end
	else
		return nil
	end

	if colorID == nil then return nil end

	return id2color[colorID]
end

function rotation(pos, angle)
	local _sc = math_cos(angle)
	local _sn = math_sin(angle)
	local x = pos.x*_sc + pos.y*_sn
	local y = pos.y*_sc - pos.x*_sn
	return pos:set(x, y)
end

---------------------------------------------------------------------------
function remove_spot(id)
	if wnd and id then
		wnd:RemoveSpot(id)
		added_spots[id] = nil
	end
end

function add_spot(id, tex)
	local obj = level.object_by_id(id)
	if not obj then return end

	if added_spots[id] then
		remove_spot(id)
	end
	added_spots[id] = tex
	db.for_map[id] = obj
end

function init()
	this.init_settings()

	wnd = UIScriptHUD()
	get_hud():AddDialogToRender(wnd)
	wnd:Show(false)
end
function destroy()
	if wnd ~= nil then
		get_hud():RemoveDialogToRender(wnd)
		wnd = nil
	end
end

function on_key_press(dik, bind)
	if bind == bind_to_show then
		if not wnd then init() end

		if level.main_input_receiver() ~= nil
		--	or bind_actor.scopeUsed
		then return end

		set_static_rescale_factor(1)
		wnd:Show(true)
		wnd.need_update = true
		if not show_quick_slots then
			ui_hud_slots.ShowSlots(true)
		end
	end
end

function on_key_release(dik, bind)
	if bind == bind_to_show then
		if not wnd then init() end
		if not wnd:IsShown() then return end
		set_static_rescale_factor(kScreen)
		wnd:Show(false)
		wnd.need_update = false
		if not show_quick_slots then
			ui_hud_slots.ShowSlots(false)
		end
	end
end

function switch_bioradar(mode)
	biodetector_mode = mode and has_alife_info("pda_biodetector_mode")
	if wnd then
		wnd:SwitchBioradar()
		wnd:RemoveAllSpots()
	end
end

function init_settings()
	local dif = level.get_game_difficulty()

	show_npc			= has_alife_info("pda_show_npc")
	show_enemy			= has_alife_info("pda_show_enemy") and dif == game_difficulty.novice
	show_corpse			= has_alife_info("pda_show_corpse") and dif ~= game_difficulty.master
	show_gps			= has_alife_info("pda_show_gps")
	show_treasures		= has_alife_info("pda_show_treasures")
	show_lc				= has_alife_info("pda_show_level_changers")
	show_time			= has_alife_info("pda_show_time")
	show_quick_slots	= has_alife_info("pda_show_quick_slots") and (game_options.QuickSlotsOnHUD ~= 1)
	biodetector_mode	= has_alife_info("pda_biodetector_mode")
							and ( inventory.on_belt("bioradar")
							or inventory.on_belt("bioradar2") )

	if wnd then
		wnd:SwitchBioradar()
		wnd:RemoveAllSpots()
		if has_alife_info("pda_dont_work") then
			wnd:Break(true)
		end
	end
end

-- сломать HUD - true, починить - false
function break_hud(mode)
	if wnd then
		wnd:Break(mode)
	end
end

-- вызывается из инфо-поршня "pda_dont_work"
function break_pda()
	this.break_hud(true)
end

function attach()
	if game_options.CurrentHUD ~= "ns_pda_script" then return end

	xr_s.subscribe("net_spawn", this.init)
	xr_s.subscribe("net_destroy", this.destroy)
	xr_s.subscribe("key_press", this.on_key_press)
	xr_s.subscribe("key_release", this.on_key_release)
end
